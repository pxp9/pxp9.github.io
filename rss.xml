<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Software Engineer Oasis</title>
      <link>https://pxp9.github.io</link>
      <description>A blog from a Software engineer</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://pxp9.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sat, 20 Sep 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Fibonacci calculation at peak performance</title>
          <pubDate>Sat, 20 Sep 2025 00:00:00 +0000</pubDate>
          <author>pxp9</author>
          <link>https://pxp9.github.io/fibonacci-calculation/</link>
          <guid>https://pxp9.github.io/fibonacci-calculation/</guid>
          <description xml:base="https://pxp9.github.io/fibonacci-calculation/">&lt;h2 id=&quot;idea&quot;&gt;Idea&lt;&#x2F;h2&gt;
&lt;p&gt;The idea of this article is to explore the Fibonacci sequence algorithms in
Elixir, explore optimizations which can be done and explore how native code can
help us in order to compute even faster. The main objective of the article is to
compute the largest Fibonacci number as fast as possible.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;start-with-the-math&quot;&gt;Start with the Math !&lt;&#x2F;h3&gt;
&lt;p&gt;Most powerful algorithms out there rely on a quite simple math principle.&lt;&#x2F;p&gt;
&lt;p&gt;$$ Fn = F_{n-1} + F_{n-2} $$&lt;&#x2F;p&gt;
&lt;p&gt;This principle means that if you know the 2 previous terms of the series you can
compute the next one. So the Fibonacci series is recursive because in the
definition of the series appears the series itself.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;math-is-not-real-life&quot;&gt;Math is not real life.&lt;&#x2F;h3&gt;
&lt;p&gt;Based on the math we have seen before we can think this algorithm:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: 0
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: 1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(n) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    fib(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) + fib(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let me tell you why this is a terrible idea. This algorithm is super slow,
because it does extra computations which are already computed and it does not store
any result.&lt;&#x2F;p&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  flowchart TB;
    root[&amp;quot;$$F_{n}$$&amp;quot;]
    f1[&amp;quot;$$F_{n-1}$$&amp;quot;]
    f2[&amp;quot;$$F_{n-2}$$&amp;quot;]
    f11[&amp;quot;$$F_{n-2}$$&amp;quot;]
    f12[&amp;quot;$$F_{n-3}$$&amp;quot;]
    f21[&amp;quot;$$F_{n-3}$$&amp;quot;]
    f22[&amp;quot;$$F_{n-4}$$&amp;quot;]
    root--&amp;gt;f1;
    root--&amp;gt;f2;
    f1--&amp;gt;f11;
    f1--&amp;gt;f12;
    f2--&amp;gt;f21;
    f2--&amp;gt;f22;
&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see from this example, the complexity of this algorithm grows exponentially $O(2^n)$.
Notice that we are doing multiple times the same computation $F_{n-2}$ or $F_{n-3}$.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;improving-naive-solution&quot;&gt;Improving naive solution.&lt;&#x2F;h3&gt;
&lt;p&gt;One improvement we can do to the solution is to apply &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dynamic_programming&quot;&gt;Dynamic
programming&lt;&#x2F;a&gt;. We can optimize
the algorithm by doing memoization, so the complexity can be reduced a lot.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(n) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.whereis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:undefined &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:named_table&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;read_concurrency: true&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    do_fib(n)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;do_fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.insert(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;, {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;})
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;do_fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.insert(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;, {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;})
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;do_fib&lt;&#x2F;span&gt;&lt;span&gt;(n) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.lookup(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;, n)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; result == [] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;      val = do_fib(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) + do_fib(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.insert(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;, {n, val})
&lt;&#x2F;span&gt;&lt;span&gt;      val
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span&gt;      [{_n, val}] = result
&lt;&#x2F;span&gt;&lt;span&gt;      val
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the same algorithm as before, but we cache the results in an &lt;a href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;elixir&#x2F;main&#x2F;ets.html&quot;&gt;ETS
table&lt;&#x2F;a&gt;, so if we have an already
computed result, we do not need to recompute it all.&lt;&#x2F;p&gt;
&lt;p&gt;We can do a simple benchmark between this implementation with memoization and
the other one with not, so it demonstrates how powerful is this technique.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;##### With input 1 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                        ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm                 16.64 M       60.09 ns ±42065.44%          45 ns          69 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.16 M      864.46 ns  ±5353.57%         792 ns        1150 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm                 16.64 M
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.16 M - 14.39x slower +804.37 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 20 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                        ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.51 M        0.66 μs  ±9240.96%        0.54 μs        0.88 μs
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm                0.0102 M       98.09 μs    ±55.81%       96.94 μs      105.33 μs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.51 M
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm                0.0102 M - 148.28x slower +97.43 μs
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 45 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                        ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.48 M      0.00000 s  ±8725.95%      0.00000 s      0.00000 s
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm               0.00000 M        16.21 s     ±0.13%        16.21 s        16.22 s
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo             1.48 M
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm               0.00000 M - 24065479.81x slower +16.21 s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#D278AA, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Benchmark Memo vs No Memo&amp;quot;
    x-axis &amp;quot;Algorithm&amp;quot; [ &amp;quot;O(2^N) input 45&amp;quot;, &amp;quot;Memo input 45&amp;quot;, &amp;quot;O(2^N) input 20&amp;quot;, &amp;quot;Memo input 20&amp;quot; ]
    y-axis &amp;quot;Time in microseconds&amp;quot; 1 --&amp;gt; 200
    bar [1622000, -1000000, 105.33, -1000000 ]
    bar [-1000000, 1.150, -1000000, 0.88]
&lt;&#x2F;pre&gt;
&lt;p&gt;For each input we flush the memoization cache, because it will be unfair if we
leave it, since it will not compute every N at least once.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sometimes-improving-is-not-enough&quot;&gt;Sometimes improving is not enough.&lt;&#x2F;h3&gt;
&lt;p&gt;Dynamic programming implementation is pretty fast, but it is not enough. We can
get a better implementation if we rethink the naive approach to make it
$O(n)$.&lt;&#x2F;p&gt;
&lt;p&gt;One trick we can do is to store the previous 2 numbers as parameters of the recursion so this way, we dont need to compute all the other results each time.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: 0
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: 1
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(n), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do:&lt;&#x2F;span&gt;&lt;span&gt; fib(n, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, _a, b), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do:&lt;&#x2F;span&gt;&lt;span&gt; b
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(n, a, b), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do:&lt;&#x2F;span&gt;&lt;span&gt; fib(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, b, a + b)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation still uses the same mathematical principle, but it does less iterations, and it uses way more less storage since it just needs to store the 2 previous fibonacci numbers.&lt;&#x2F;p&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  flowchart LR;
    root[&amp;quot;$$F_{n}$$&amp;quot;]
    f1[&amp;quot;$$F_{n-1}$$&amp;quot;]
    f2[&amp;quot;$$F_{n-2}$$&amp;quot;]
    f0[&amp;quot;$$F_{0}$$&amp;quot;]
    f01[&amp;quot;$$F_{1}$$&amp;quot;]
    root--&amp;gt;f1;
    f1--&amp;gt;f2;
    f2--&amp;gt;f01;
    f01--&amp;gt;f0;
&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;what-about-another-math-approach&quot;&gt;What about another math approach ?&lt;&#x2F;h3&gt;
&lt;p&gt;There is another mathematical formula called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fibonacci_sequence#Closed-form_expression&quot;&gt;Binet&#x27;s formula&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;$$ Fn = \frac{\phi^{n} - (-\phi^{-n})} {\sqrt{5}} $$&lt;&#x2F;p&gt;
&lt;p&gt;This principle allow us to calculate any number of the sequence by just knowing
the value of $\phi$ constant.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;phi_formula&lt;&#x2F;span&gt;&lt;span&gt;(n),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do:&lt;&#x2F;span&gt;&lt;span&gt; round((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:math&lt;&#x2F;span&gt;&lt;span&gt;.pow(@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;phi&lt;&#x2F;span&gt;&lt;span&gt;, n) - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:math&lt;&#x2F;span&gt;&lt;span&gt;.pow(-@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;phi&lt;&#x2F;span&gt;&lt;span&gt;, -n)) * fast_inverse_square_root(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5.0&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fast_inverse_square_root&lt;&#x2F;span&gt;&lt;span&gt;(number) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    x2 = number * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.5
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&amp;lt;i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;::integer-size(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; = &amp;lt;&amp;lt;number&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;::float-size(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&amp;lt;y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;::float-size(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; = &amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x5FE6EB50C7B537A9&lt;&#x2F;span&gt;&lt;span&gt; - (i &amp;gt;&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)::integer-size(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    y = y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y)
&lt;&#x2F;span&gt;&lt;span&gt;    y = y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y)
&lt;&#x2F;span&gt;&lt;span&gt;    y = y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y)
&lt;&#x2F;span&gt;&lt;span&gt;    y
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation is in fact $O(1)$ or $O(log n)$, depends on the complexity of &lt;code&gt;:math.pow&lt;&#x2F;code&gt; function. What is the tradeoff ? This implementation is an approximation so you will be stacking error. Notice that one divided the square root of 5 is calculated with the &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=p8u_k2LIZyo&amp;amp;pp=ygUgcXVha2UgMyBmYXN0IGludmVyc2Ugc3F1YXJlIHJvb3Q%3D&quot;&gt;quake 3 algorithm&lt;&#x2F;a&gt;, another alternative would be to hardcode this constant in the algorithm.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-end&quot;&gt;The end ?&lt;&#x2F;h3&gt;
&lt;p&gt;So... Is this the end ?&lt;&#x2F;p&gt;
&lt;p&gt;NO, because you should know that Elixir runs in the Erlang VM which probably has some overhead
while calculating. We can try to make an Erlang &lt;code&gt;NIF&lt;&#x2F;code&gt; (&lt;strong&gt;Native Implementation Function&lt;&#x2F;strong&gt;), to see if it is faster than just standard Elixir.&lt;&#x2F;p&gt;
&lt;p&gt;To do so, we can take a look to &lt;code&gt;rustler&lt;&#x2F;code&gt;, which is fantastic &lt;code&gt;crate&lt;&#x2F;code&gt;&#x2F;elixir library.&lt;&#x2F;p&gt;
&lt;p&gt;This is the code we will be using in Rust,&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rustler&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nif&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u128 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; b = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; i &amp;lt; n {
&lt;&#x2F;span&gt;&lt;span&gt;        b = a + b;
&lt;&#x2F;span&gt;&lt;span&gt;        a = b - a;
&lt;&#x2F;span&gt;&lt;span&gt;        i += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    b
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and for the $\phi$ based algorithm,&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PHI&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.618033988749895&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;inv_sqrt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; i = x.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_bits&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; x2 = x * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.5&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; y = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;::from_bits(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x5FE6EB50C7B537A9 &lt;&#x2F;span&gt;&lt;span&gt;- (i &amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;    y = y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y);
&lt;&#x2F;span&gt;&lt;span&gt;    y = y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y);
&lt;&#x2F;span&gt;&lt;span&gt;    y * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1.5 &lt;&#x2F;span&gt;&lt;span&gt;- x2 * y * y)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rustler&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nif&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;phi_formula&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PHI&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;powi&lt;&#x2F;span&gt;&lt;span&gt;(n) - (-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PHI&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;powi&lt;&#x2F;span&gt;&lt;span&gt;(-n)) * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;inv_sqrt&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5.0&lt;&#x2F;span&gt;&lt;span&gt;)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ceil&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Of course the &lt;code&gt;phi_formula&lt;&#x2F;code&gt; implementation has the same issue as the elixir one since it is an approximation, it should not be super precise at large scale.&lt;&#x2F;p&gt;
&lt;p&gt;Lets talk about the Rust implementation of Fibonacci, as you can see is $O(N)$ and notice we are just using 2 variables instead of 3, this is because an arithmetic operation should be faster than storing in a CPU register. Also notice that Rust forces us to put types and,
we are using &lt;code&gt;u128&lt;&#x2F;code&gt;, so this way we can compute and store really big integer.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wait-something-weird-is-happening&quot;&gt;Wait something weird is happening&lt;&#x2F;h3&gt;
&lt;p&gt;When I was testing the code for this article, I realized that sometimes Rust implementation was not consistant with the Elixir one, especially at large scale.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Elixir impl with 100 input
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;354224848179261915075
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Rust impl with 100 input
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;354224848179261915075
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Elixir impl with 200 input
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;280571172992510140037611932413038677189525
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Rust impl with 200 input
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;178502649656846143791255889261670949781
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It seems everything is correct, for &lt;code&gt;100&lt;&#x2F;code&gt;, but things are getting weird for &lt;code&gt;200&lt;&#x2F;code&gt;.
What the hell the same algorithm gives different result ?&lt;&#x2F;p&gt;
&lt;p&gt;The answer is called overflow. Since Rust is working with limited size integers it overflows for big numbers.&lt;&#x2F;p&gt;
&lt;p&gt;Why Elixir does not have this problem ? It is because Elixir integers are dynamically sized. It creates a little bit of overhead because you must do allocations to fit the integer, but it allows you to have an &quot;infinite&quot; integer. I recommend this read &lt;a href=&quot;https:&#x2F;&#x2F;dev.to&#x2F;abreujp&#x2F;understanding-numbers-in-elixir-na5&quot;&gt;Learning Elixir: Understanding Numbers&lt;&#x2F;a&gt;, in order to have a better understanding of what Elixir is doing.&lt;&#x2F;p&gt;
&lt;p&gt;Then I wondered, What if I can make the same Elixir behaviour in Rust ?&lt;&#x2F;p&gt;
&lt;p&gt;Thankfully, there are already super smart people in the Rust ecosystem that thought about
this problem, and I observed that there was already a &lt;code&gt;crate&lt;&#x2F;code&gt; for this &lt;code&gt;num_bigint&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Another thing, one of the guys who did &lt;code&gt;rustler&lt;&#x2F;code&gt;, thought about this problem and
he integrated &lt;code&gt;rustler&lt;&#x2F;code&gt; with &lt;code&gt;num_bigint&lt;&#x2F;code&gt;, so this way you can have a translation layer with these kind of integers in Rust. Take a look the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;rustler&#x2F;latest&#x2F;rustler&#x2F;struct.BigInt.html#impl-Encoder-for-BigInt&quot;&gt;Encoder impl for BigInt&lt;&#x2F;a&gt;, this is the translation layer for Rust &lt;code&gt;BigInt&lt;&#x2F;code&gt; to Elixir &lt;code&gt;term&lt;&#x2F;code&gt; which is an &lt;code&gt;integer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Lets take a look to the implementation with &lt;code&gt;BigInt&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rustler&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nif&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fib_bignums&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u128&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; BigInt {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; a = BigUint::zero();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; b = BigUint::one();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while&lt;&#x2F;span&gt;&lt;span&gt; i &amp;lt; n {
&lt;&#x2F;span&gt;&lt;span&gt;        b = &amp;amp;a + &amp;amp;b;
&lt;&#x2F;span&gt;&lt;span&gt;        a = &amp;amp;b - &amp;amp;a;
&lt;&#x2F;span&gt;&lt;span&gt;        i += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    BigInt::from_biguint(Sign::Plus, b)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see nothing really changes, now we are using the big integer which are resizable,
and allow us to store massive integers.&lt;&#x2F;p&gt;
&lt;p&gt;Lets try with this implementation and see if it gives the same result as Elixir one.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Elixir with input 200
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;280571172992510140037611932413038677189525
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Rust `u128` with input 200
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;178502649656846143791255889261670949781
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Rust resizable integers with input 200
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib_bignums(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;280571172992510140037611932413038677189525
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;YES! It works! Now we can compute and store massive Fibonacci calculations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;theory-pretty-cool-but-show-me-the-numbers&quot;&gt;Theory pretty cool, but show me the numbers.&lt;&#x2F;h3&gt;
&lt;p&gt;Ok ok, now is the moment you were waiting for! The benchmarks and see if the theory is confirmed.&lt;&#x2F;p&gt;
&lt;p&gt;The benchmark library I will be using is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bencheeorg&#x2F;benchee&quot;&gt;Benchee&lt;&#x2F;a&gt;, this library allow me to compare and obtain stats for each implementation
and different inputs.&lt;&#x2F;p&gt;
&lt;p&gt;I would like to explain I have divided the benchmarking in 2. Relative small inputs,
less than &lt;code&gt;100&lt;&#x2F;code&gt;, and really big inputs from &lt;code&gt;200_000&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These are the specs of my system&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Operating System: Linux
&lt;&#x2F;span&gt;&lt;span&gt;CPU Information: 13th Gen Intel(R) Core(TM) i5-1335U
&lt;&#x2F;span&gt;&lt;span&gt;Number of Available Cores: 12
&lt;&#x2F;span&gt;&lt;span&gt;Available memory: 15.30 GB
&lt;&#x2F;span&gt;&lt;span&gt;Elixir 1.18.4
&lt;&#x2F;span&gt;&lt;span&gt;Erlang 27.3.4.3
&lt;&#x2F;span&gt;&lt;span&gt;JIT enabled: true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the setup for low inputs.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bench&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Benchee&lt;&#x2F;span&gt;&lt;span&gt;.run(
&lt;&#x2F;span&gt;&lt;span&gt;      %{
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elixir O(N) Algorithm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elixir O(2^n) Algorithm Memo&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dp_slow_fib&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elixir O(1) Algorithm Phi formula&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;phi_formula&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rust O(1) Algorithm Phi formula&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rust O(N) Algorithm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rust O(N) Algorithm expanding nums&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;          &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib_bignums&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;      },
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;inputs:&lt;&#x2F;span&gt;&lt;span&gt; %{
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;71&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;71&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100
&lt;&#x2F;span&gt;&lt;span&gt;      },
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;parallel: 2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;after_scenario: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt; _input -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.whereis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;) != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:undefined &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:ets&lt;&#x2F;span&gt;&lt;span&gt;.delete(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:fibs&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Before you look the results you need to consider that Rust expanding nums implementation was run with the dirty scheduler in Erlang, without it is still the worst, because of the overhead it has, but not so much worse around 33x slower. Also consider invalid $\Phi$ formula implementations for the &lt;code&gt;input &amp;gt;= 71&lt;&#x2F;code&gt; or &lt;code&gt;input &amp;gt;= 75&lt;&#x2F;code&gt;, because they start to not give a precise value after that.&lt;&#x2F;p&gt;
&lt;p&gt;As you can see here the result for input 71 is correct for 72 is not, as well in the $\phi$ elixir implementation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;### Input 71
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;71&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;308061521170129.0
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;71&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;308061521170129
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;### Input 72
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;72&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;498454011879263.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;72&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;498454011879264
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;72&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;498454011879264
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;### Input 75
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;75&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2111485077978050
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;75&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2111485077978050
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;### Input 76
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FibRustElixir&lt;&#x2F;span&gt;&lt;span&gt;.phi_formula(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;76&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3416454622906708
&lt;&#x2F;span&gt;&lt;span&gt;iex(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;76&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3416454622906707
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here are the results for the benchmark low inputs.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;##### With input 1 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                    16.38 M       61.07 ns ±45774.27%          44 ns          71 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           9.15 M      109.26 ns  ±4221.28%         100 ns         210 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       8.26 M      121.09 ns ±23343.76%         100 ns         203 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.31 M      302.31 ns   ±136.52%         260 ns         531 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.19 M      838.18 ns  ±5624.56%         787 ns        1101 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums       0.188 M     5308.94 ns    ±84.14%        4395 ns    16176.06 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                    16.38 M
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           9.15 M - 1.79x slower +48.19 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       8.26 M - 1.98x slower +60.03 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.31 M - 4.95x slower +241.25 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.19 M - 13.73x slower +777.11 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums       0.188 M - 86.93x slower +5247.87 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 100 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           8.09 M      123.63 ns   ±263.70%         113 ns         195 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       4.63 M      215.80 ns   ±356.51%         198 ns         419 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.15 M      317.82 ns   ±209.58%         277 ns         615 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.45 M      687.71 ns  ±8165.87%         587 ns         924 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.66 M     1517.15 ns  ±2172.62%        1380 ns        1928 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums      0.0784 M    12753.08 ns    ±55.31%       13905 ns       24389 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           8.09 M
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       4.63 M - 1.75x slower +92.17 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.15 M - 2.57x slower +194.18 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.45 M - 5.56x slower +564.08 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.66 M - 12.27x slower +1393.51 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums      0.0784 M - 103.15x slower +12629.45 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 71 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           7.75 M      128.97 ns  ±4535.63%         117 ns         230 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       6.54 M      152.88 ns ±19215.97%         123 ns         224 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.40 M      294.01 ns   ±339.67%         258 ns         533 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.43 M      700.42 ns  ±9294.91%         581 ns         904 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     1.15 M      869.80 ns   ±184.80%         853 ns        1259 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums      0.0940 M    10633.12 ns    ±73.98%       10948 ns       20597 ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(1) Algorithm Phi formula           7.75 M
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm                       6.54 M - 1.19x slower +23.91 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(1) Algorithm Phi formula         3.40 M - 2.28x slower +165.04 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(2^n) Algorithm Memo              1.43 M - 5.43x slower +571.45 ns
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     1.15 M - 6.74x slower +740.83 ns
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums      0.0940 M - 82.44x slower +10504.15 ns
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#B7410E, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Low numbers benchmark input 1&amp;quot;
    x-axis &amp;quot;Algorithm&amp;quot; [&amp;quot;Rust Phi&amp;quot;, &amp;quot;Elixir Phi&amp;quot;, &amp;quot;Rust O(N)&amp;quot;, &amp;quot;Elixir O(N)&amp;quot;, &amp;quot;Elixir O(2^N) Memo&amp;quot; ]
    y-axis &amp;quot;Time in nanoseconds&amp;quot; 1 --&amp;gt; 1200
    bar [210, -1000, 203 ,-1000, -1000]
    bar [-1000, 531, -1000 , 71, 1101]
&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#B7410E, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Low numbers benchmark input 71&amp;quot;
    x-axis &amp;quot;Algorithm&amp;quot; [&amp;quot;Rust Phi&amp;quot;, &amp;quot;Elixir Phi&amp;quot;, &amp;quot;Rust O(N)&amp;quot;, &amp;quot;Elixir O(N)&amp;quot;, &amp;quot;Elixir O(2^N) Memo&amp;quot; ]
    y-axis &amp;quot;Time in nanoseconds&amp;quot; 1 --&amp;gt; 1300
    bar [230, -1000, 224 ,-1000, -1000]
    bar [-1000, 533, -1000 , 1259, 904]
&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#B7410E, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Low numbers benchmark input 100&amp;quot;
    x-axis &amp;quot;Algorithm&amp;quot; [&amp;quot;Rust O(N)&amp;quot;, &amp;quot;Elixir O(N)&amp;quot;, &amp;quot;Elixir O(2^N) Memo&amp;quot; ]
    y-axis &amp;quot;Time in nanoseconds&amp;quot; 1 --&amp;gt; 2000
    bar [419,-1000, -1000]
    bar [-1000 , 1928, 924]
&lt;&#x2F;pre&gt;
&lt;p&gt;The conclusion we can make here is that for really small inputs Rust NIF is
worth it to use even if Elixir wins for input 1 because it is a clause in the
function almost without any overhead. $\Phi$ algorithm is not so fast for low
inputs so it is not worth to use. Notice that Rust expandable integers
implementation has a super big overhead which is not compensate with the small
input.&lt;&#x2F;p&gt;
&lt;p&gt;This is the setup I was doing for Big numbers,&lt;&#x2F;p&gt;
&lt;p&gt;As you can see here we have much bigger inputs, other functions cannot be included in
this benchmark because they will lose &lt;code&gt;precision&lt;&#x2F;code&gt;, they will take too much &lt;code&gt;time&lt;&#x2F;code&gt; or
they will take too much &lt;code&gt;memory&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bench_large_numbers&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Benchee&lt;&#x2F;span&gt;&lt;span&gt;.run(
&lt;&#x2F;span&gt;&lt;span&gt;      %{
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elixir O(N) Algorithm&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fib&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rust O(N) Algorithm expanding nums&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TurboFibonacci&lt;&#x2F;span&gt;&lt;span&gt;.fib_bignums&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;      },
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;inputs:&lt;&#x2F;span&gt;&lt;span&gt; %{
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;200_000&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200_000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;500_000&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;500_000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1 Million&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1_000_000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2 Million&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2_000_000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      },
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;parallel: 2
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are the results for the big numbers benchmark.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;##### With input 1 Million #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums        0.0890        11.23 s     ±0.09%        11.23 s        11.24 s
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.0798        12.54 s     ±0.00%        12.54 s        12.54 s
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums        0.0890
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.0798 - 1.12x slower +1.30 s
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 2 Million #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.0238       0.70 min     ±2.11%       0.70 min       0.71 min
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums        0.0101       1.64 min     ±0.01%       1.64 min       1.64 min
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                     0.0238
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums        0.0101 - 2.35x slower +0.94 min
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 200_000 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums          3.04      328.71 ms     ±0.56%      328.21 ms      333.74 ms
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                       1.50      668.81 ms     ±5.29%      659.64 ms      728.12 ms
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums          3.04
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                       1.50 - 2.03x slower +340.10 ms
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;##### With input 500_000 #####
&lt;&#x2F;span&gt;&lt;span&gt;Name                                         ips        average  deviation         median         99th %
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums          0.44         2.25 s     ±0.14%         2.25 s         2.25 s
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                       0.23         4.33 s     ±2.59%         4.33 s         4.43 s
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Comparison:
&lt;&#x2F;span&gt;&lt;span&gt;Rust O(N) Algorithm expanding nums          0.44
&lt;&#x2F;span&gt;&lt;span&gt;Elixir O(N) Algorithm                       0.23 - 1.93x slower +2.09 s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#B7410E, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Big numbers benchmark&amp;quot;
    x-axis &amp;quot;Algorithm and input&amp;quot; [&amp;quot;E(200k)&amp;quot;, &amp;quot;R(200k)&amp;quot;, &amp;quot;E(500k)&amp;quot;, &amp;quot;R(500k)&amp;quot;, &amp;quot;E(1M)&amp;quot;, &amp;quot;R(1M)&amp;quot; ]
    y-axis &amp;quot;Time in seconds&amp;quot; 0 --&amp;gt; 15
    bar [-1, 0.33374, -1 , 2.25, -1, 11.24]
    bar [0.72812, -1, 4.43 ,-1, 12.54, -1]
&lt;&#x2F;pre&gt;
&lt;pre class=&quot;mermaid bg-inherit&quot;&gt;
  ---
config:
  themeVariables:
    xyChart:
      plotColorPalette: &amp;#x27;#B7410E, #7C6D91&amp;#x27;
---
xychart
    title &amp;quot;Big numbers benchmark (2 million)&amp;quot;
    x-axis &amp;quot;Algorithm and input&amp;quot; [&amp;quot;E(2M)&amp;quot;, &amp;quot;R(2M)&amp;quot;]
    y-axis &amp;quot;Time in seconds&amp;quot; 1 --&amp;gt; 100
    bar [ -1 , 98.4 ]
    bar [42.6  ,-1 ]
&lt;&#x2F;pre&gt;
&lt;p&gt;This is really interesting result, since it seems Rust expanding nums it pays the overhead by winning Elixir to all the inputs except for 2 million, I believe why Elixir wins in 2 million input is because some sort of reallocation optimization which is not in Rust.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h3&gt;
&lt;p&gt;For every peak performance algorithm you should analyze your inputs and make correct assumptions like &lt;code&gt;input &amp;lt;= 71&lt;&#x2F;code&gt;, so this way you benefit of the approximation algorithm.&lt;&#x2F;p&gt;
&lt;p&gt;If your inputs are super large, consider using native code, instead of working in VM code.
It seems to pay off the Native code, in fact Elixir is kinda cheating because Erlang is probably calling some C code to compute this kinda numbers.&lt;&#x2F;p&gt;
&lt;p&gt;Benchmark! Always test your things with stress, load and speed benchmarking, this way you can ensure that your algorithm is gonna behave how you will expect.&lt;&#x2F;p&gt;
&lt;p&gt;Of course there is much more strategies here which I did not cover, like Multi-threading, dividing the work in chunks and so on...&lt;&#x2F;p&gt;
&lt;p&gt;Hopefully you liked the article, all the code of the article is available in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pxp9&#x2F;fibonacci_numbers&quot;&gt;Github&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Lazy Doc, Your documentation tool has arrived.</title>
          <pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate>
          <author>pxp9</author>
          <link>https://pxp9.github.io/lazy-doc/</link>
          <guid>https://pxp9.github.io/lazy-doc/</guid>
          <description xml:base="https://pxp9.github.io/lazy-doc/">&lt;h2 id=&quot;idea&quot;&gt;Idea&lt;&#x2F;h2&gt;
&lt;p&gt;All started with a conversation with my boss, I was talking to him about a game
we play (Balatro, wonderful game), and suddenly he asked, Are you using AI to
program ? I told him that current the state of the AI is not that good for
suggesting &lt;strong&gt;production&lt;&#x2F;strong&gt; code, but it is good to suggest other things like
explanations, suggest syntax fixes, etc... One of the problems we have in my
company codebase is that we have so much undocumented code, which is not a big
problem at all, because we have a really clear API of how to interact, but each
time someone new comes to the project, you need to explain the localized
knowledge. We also talked about AI writing docs might be good, but we did not
even know because we had not tested yet. That was how Lazy Doc idea came from.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-lazy-doc&quot;&gt;What is Lazy Doc ?&lt;&#x2F;h2&gt;
&lt;p&gt;Lazy Doc is a tool to improve your nonexistent or missing Elixir docs via AI. It
detects undocumented functions, it gives the source code to the AI and it
generates documentation based on it.&lt;&#x2F;p&gt;
&lt;p&gt;You just need to install it and configure it, execute &lt;code&gt;mix lazy_doc&lt;&#x2F;code&gt; and boom
you have brand new documentation from scratch.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;purpose&quot;&gt;Purpose&lt;&#x2F;h3&gt;
&lt;p&gt;The purpose of &lt;code&gt;Lazy Doc&lt;&#x2F;code&gt; is much bigger it aims to be a docs checker as well.&lt;&#x2F;p&gt;
&lt;p&gt;with &lt;code&gt;mix lazy_doc.check&lt;&#x2F;code&gt; you can check if all the documentation under
&lt;code&gt;patterns&lt;&#x2F;code&gt; paths regex. This check can be easily implemented in the CI, so if
you forget to document something CI will not pass.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;documentation-criteria&quot;&gt;Documentation criteria&lt;&#x2F;h3&gt;
&lt;p&gt;Lazy Doc will only document functions which agree with the following criteria:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Public functions not already documented. (already documented functions are
ignored)&lt;&#x2F;li&gt;
&lt;li&gt;Public functions without hidden documentation tag &lt;code&gt;@doc false&lt;&#x2F;code&gt;. (hidden docs
function are ignored).&lt;&#x2F;li&gt;
&lt;li&gt;Private functions are ignored (&lt;em&gt;but included in the prompt if they are
auxiliary functions continue reading for more info&lt;&#x2F;em&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;so this way if &lt;code&gt;lazy_doc.check&lt;&#x2F;code&gt; does not pass because of a function, you take
one of the following actions.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Make the function private&lt;&#x2F;li&gt;
&lt;li&gt;Make the doc hidden&lt;&#x2F;li&gt;
&lt;li&gt;Document or just execute &lt;code&gt;mix lazy_doc&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The main reason LazyDoc can be really good for your project, it is because it
will enforce you to write documentation. Even if you do not want it, it offers a
good start template.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-is-it-built&quot;&gt;How is it built ?&lt;&#x2F;h2&gt;
&lt;p&gt;Okay, you want to build a an automatic documentor, right ? So the first step is
to detect what the hell you should document and what you should not and &lt;strong&gt;leave
it as it is&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;What alternatives do you have to detect undocumented functions ?&lt;&#x2F;p&gt;
&lt;p&gt;You always need to read the file at least once and then you have multiple
approaches.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;process-line-by-line-approach&quot;&gt;Process line by line approach&lt;&#x2F;h3&gt;
&lt;p&gt;This approach consist to check each line and look for search patterns, in our
case &lt;code&gt;@doc whatever&lt;&#x2F;code&gt; on top of a function.&lt;&#x2F;p&gt;
&lt;p&gt;There are a bunch of problems with this approach:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;how do you get the code of a single function and its clauses ? you can try to
read lines until one end , but how do you know if it is an &lt;code&gt;end&lt;&#x2F;code&gt; of a &lt;code&gt;case&lt;&#x2F;code&gt;
or an &lt;code&gt;end&lt;&#x2F;code&gt; of the &lt;code&gt;def&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;how do you retain the format of the file ?&lt;&#x2F;li&gt;
&lt;li&gt;how do you detect inner inner modules ?&lt;&#x2F;li&gt;
&lt;li&gt;how do you detect if a function is inside an inner module or not ?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As you can see this is a simple approach, but it has a bunch of problems and
probably many more problems, which I had not thought, because I did not even try
to implement it this way.&lt;&#x2F;p&gt;
&lt;p&gt;So what is the alternative ?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;asts-for-the-king-approach&quot;&gt;ASTs for the king approach&lt;&#x2F;h3&gt;
&lt;p&gt;Okay, so we are gonna try to detect functions through the AST of the module but
first, let&#x27;s explain what an AST is. An AST is a data structure which contains
the syntax of the code, in fact it stands for &lt;em&gt;Abstract Syntax Tree&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In Elixir an AST has always the same pattern.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:defmodule &lt;&#x2F;span&gt;&lt;span&gt;= name, [...] = meta, [...] = children } = node
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So you get the AST of file, via &lt;code&gt;Code.string_to_quote()&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;For instance this module, it will have the corresponding AST&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defmodule &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Example &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;@doc &amp;quot;converts to string&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;(n) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Kernel&lt;&#x2F;span&gt;&lt;span&gt;.to_string(n)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;em&gt;Note: you can experiment with &lt;a href=&quot;https:&#x2F;&#x2F;pxp9.github.io&#x2F;lazy-doc&#x2F;ast.ninja&quot;&gt;ast.ninja site&lt;&#x2F;a&gt; if you want to
experiment with ASTs&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;    {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:defmodule&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 1&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;     [
&lt;&#x2F;span&gt;&lt;span&gt;       {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:__aliases__&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 1&lt;&#x2F;span&gt;&lt;span&gt;], [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:Example&lt;&#x2F;span&gt;&lt;span&gt;]},
&lt;&#x2F;span&gt;&lt;span&gt;       [
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:__block__&lt;&#x2F;span&gt;&lt;span&gt;, [],
&lt;&#x2F;span&gt;&lt;span&gt;          [
&lt;&#x2F;span&gt;&lt;span&gt;            {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:@&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 2&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;             [
&lt;&#x2F;span&gt;&lt;span&gt;               {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:doc&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 2&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;converts to string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]}
&lt;&#x2F;span&gt;&lt;span&gt;             ]},
&lt;&#x2F;span&gt;&lt;span&gt;            {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:def&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 3&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;             [
&lt;&#x2F;span&gt;&lt;span&gt;               {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:number&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 3&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                [{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:n&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 3&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil&lt;&#x2F;span&gt;&lt;span&gt;}]},
&lt;&#x2F;span&gt;&lt;span&gt;               [
&lt;&#x2F;span&gt;&lt;span&gt;                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: &lt;&#x2F;span&gt;&lt;span&gt;{{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:.&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 4&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                   [
&lt;&#x2F;span&gt;&lt;span&gt;                     {&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:__aliases__&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                      [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 4&lt;&#x2F;span&gt;&lt;span&gt;], [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:Kernel&lt;&#x2F;span&gt;&lt;span&gt;]},
&lt;&#x2F;span&gt;&lt;span&gt;                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:to_string
&lt;&#x2F;span&gt;&lt;span&gt;                   ]}, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 4&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;                  [{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:n&lt;&#x2F;span&gt;&lt;span&gt;, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;line: 4&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil&lt;&#x2F;span&gt;&lt;span&gt;}]}
&lt;&#x2F;span&gt;&lt;span&gt;               ]
&lt;&#x2F;span&gt;&lt;span&gt;             ]}
&lt;&#x2F;span&gt;&lt;span&gt;          ]}
&lt;&#x2F;span&gt;&lt;span&gt;       ]
&lt;&#x2F;span&gt;&lt;span&gt;     ]}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can just pattern match the node you want and get the code from that node.
for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;:def &lt;&#x2F;span&gt;&lt;span&gt;= name, [...] = meta, [...] = children } = ast_fun
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In &lt;code&gt;ast_fun&lt;&#x2F;code&gt; we have the sub ast of that function we just need to convert it
back to code and send it to analyze with AI, but just if it is not documented.&lt;&#x2F;p&gt;
&lt;p&gt;And you know that &lt;code&gt;number&lt;&#x2F;code&gt; function is in the &lt;code&gt;Example&lt;&#x2F;code&gt; module because it was in
their children nodes list.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-do-you-convert-ast-to-string-again&quot;&gt;How do you convert AST to String again ?&lt;&#x2F;h4&gt;
&lt;p&gt;You can just use &lt;code&gt;Macro.to_string(ast_fun)&lt;&#x2F;code&gt;. (There is some caviar on this,
continue reading).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;how-do-we-know-if-a-function-is-already-documented-or-not&quot;&gt;How do we know if a function is already documented or not ?&lt;&#x2F;h4&gt;
&lt;p&gt;Easy, you just need to call &lt;code&gt;Code.fetch_docs(module)&lt;&#x2F;code&gt; which requires to give the
name of the module.&lt;&#x2F;p&gt;
&lt;p&gt;Not so fast, what happens if you have the same name of function with different
number of arguments (different arities not clauses). This function will return
you documentation for each different function in the language, but are 2
functions with the same name different from each other, just because their arity
differs? The answer is &lt;strong&gt;YES&lt;&#x2F;strong&gt;, but does this make sense in the POV of
documentation. Think for a moment of what coding situation would you use the
same name with different arities.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a look this example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;## Look this function, does make sense if you hide the other functions ?
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fibs&lt;&#x2F;span&gt;&lt;span&gt;(n) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  fibs(n, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fibs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, [a, b | rest]), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;do: &lt;&#x2F;span&gt;&lt;span&gt;[a + b, a, b | rest]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fibs&lt;&#x2F;span&gt;&lt;span&gt;(n, [a, b | rest]) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  fibs(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, [a + b, a, b | rest])
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Probably just because one of the functions is auxiliary of the other. So the
auxiliary function does not make sense by itself and the entry point function
does not make sense without the auxiliary. We need a way to group up the
functions by name even if they have different arity and clauses (function same
name and same arity) to send it to AI in a single prompt.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fetch-the-prompt&quot;&gt;Fetch the prompt&lt;&#x2F;h3&gt;
&lt;p&gt;Okay, you need a way to get the documentation using AI&lt;&#x2F;p&gt;
&lt;p&gt;So what you should do is to call an AI API, but which one ?&lt;&#x2F;p&gt;
&lt;p&gt;There is a bunch of AI APIs and everyone has its favorite AI. Not talking about
if you want to use an internal model of the company, it could be really hard. So
why not give freedom to call your own AI ?&lt;&#x2F;p&gt;
&lt;p&gt;You just need to implement the &lt;code&gt;LazyDoc.Provider&lt;&#x2F;code&gt; behavior. This is the contract
that will use &lt;code&gt;LazyDoc&lt;&#x2F;code&gt; to request the docs to API and extract them from the
response.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;make-a-good-prompt-ai-is-like-a-kid-explain-what-you-want&quot;&gt;Make a good prompt (AI is like a kid explain what you want).&lt;&#x2F;h3&gt;
&lt;p&gt;Making a good prompt is really important for fetching the docs, you should
specify your prompt always with at least one example and be precise with the
format you want.&lt;&#x2F;p&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;~s&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;You should describe the parameters based on the spec given and give a small description of the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; following function.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Please do it in the following format given as an example, important do not
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; return the header of the function, do not return a explanation of the function, your output must
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;be only the docs in the following format:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Returns the Transaction corresponding to
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;transaction_id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Initial sentence indicating what returns the function&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\)\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;## Parameters&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;-
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;transaction_id - foreign key of the Transactions table.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;## Description&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; Performs a search in the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;database&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Function to document:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the default prompt the library will use, to this prompt you should
concatenate the function code. Of course there is a bunch of attempts to get the
right prompt and you need to even consider to be compliant with existing doc
tools.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;insert-the-docs-on-the-ast&quot;&gt;Insert the docs on the AST&lt;&#x2F;h3&gt;
&lt;p&gt;To insert the doc in the AST you just need to create a &lt;code&gt;@doc&lt;&#x2F;code&gt; node and insert it
just before &lt;code&gt;def&lt;&#x2F;code&gt; node.&lt;&#x2F;p&gt;
&lt;p&gt;but what if this &lt;code&gt;def&lt;&#x2F;code&gt; node is in an inner module children. You need to find
first the children of the corresponding module. &lt;em&gt;JUST pattern match&lt;&#x2F;em&gt;, it will
work (complex pattern match but I promise, it will work). Once you have the
children, need to locate the &lt;code&gt;def&lt;&#x2F;code&gt; node position in the children and then insert
it just one position before.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-end-of-the-trip&quot;&gt;The end of the trip ?&lt;&#x2F;h3&gt;
&lt;p&gt;And then transform the AST to String with &lt;code&gt;Macro.to_string()&lt;&#x2F;code&gt; and write it to
the corresponding file, right ?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;WRONG&lt;&#x2F;strong&gt;, you just messed up all the format of the original file.&lt;&#x2F;p&gt;
&lt;p&gt;What? Where are my comments? it just deleted my comments during the entire
process.&lt;&#x2F;p&gt;
&lt;p&gt;How do you fix it ?&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-master-talk-about-ast-manipulation&quot;&gt;The master talk about AST manipulation.&lt;&#x2F;h3&gt;
&lt;p&gt;At this point, you are almost there, almost done, but you are kind of stuck
because you want to preserve the code as it was. Remember this ?&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;leave the code as it is&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;It is one of the premises that we have at least to use it in production.&lt;&#x2F;p&gt;
&lt;p&gt;Surprise surprise, you have seen it before, it is the &lt;code&gt;AST NINJA&lt;&#x2F;code&gt; talk. Actually
the name of the talk is &lt;code&gt;The Elixir parser under microscope&lt;&#x2F;code&gt; by &lt;code&gt;Arjan Scherpenisse&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This talk is about how to preserve the code as it is after an AST manipulation.
Basically what you need to do is what the Elixir Formatter does, Add tokenizer
metadata to AST, store the comments outside the AST and merge it after all the
AST manipulation.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately this talk was done years ago and the Elixir std library changed
according the talk recommendations, so we just need to use
&lt;code&gt;Code.string_to_quote_with_comments&lt;&#x2F;code&gt; with some options and then after the AST
manipulation use&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;ast
&lt;&#x2F;span&gt;&lt;span&gt;|&amp;gt; quote_to_algebra(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;comments:&lt;&#x2F;span&gt;&lt;span&gt; comments, ...)
&lt;&#x2F;span&gt;&lt;span&gt;|&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Inspect&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Algebra&lt;&#x2F;span&gt;&lt;span&gt;.format(max_line_width_configured)
&lt;&#x2F;span&gt;&lt;span&gt;|&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;IO&lt;&#x2F;span&gt;&lt;span&gt;.iodata_to_binary()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This will preserve the format of the file.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;feature-requests&quot;&gt;Feature requests&lt;&#x2F;h2&gt;
&lt;p&gt;After telling you how you can build LazyDoc, I can tell you what features
request were requested.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;They requested a way to not have bloated documentation files, the issue users
found was that generating so much docs will cause the file incresize the size
dramatically. So in order to address it, I added the &lt;code&gt;external_doc&lt;&#x2F;code&gt; option
which allows you to write the doc in a separate markdown file and read the doc
of that function at compile time.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;priv&#x2F;lazy_doc&#x2F;lazy_doc&#x2F;docs_per_module.md&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;md&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-md &quot;&gt;&lt;code class=&quot;language-md&quot; data-lang=&quot;md&quot;&gt;&lt;span&gt;Returns a list of documentation for each function in the specified modules.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;## Parameters
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;- modules - a list of module names to extract documentation from.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;## Description
&lt;&#x2F;span&gt;&lt;span&gt; Retrieves the documentation for functions in the given modules using Elixir&amp;#39;s introspection capabilities.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;lib&#x2F;lazy_doc.ex&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;  @&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;doc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;File&lt;&#x2F;span&gt;&lt;span&gt;.read!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;priv&#x2F;lazy_doc&#x2F;lazy_doc&#x2F;docs_per_module.md&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;docs_per_module&lt;&#x2F;span&gt;&lt;span&gt;(modules) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;this way, you can enjoy a rich documentation without having big blocks of
documentation before each function. Even the LSP will give you the documentation
if you hover over the function, because the documentation is embedded in the
&lt;code&gt;.beam&lt;&#x2F;code&gt; file.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In the article, we focus on the functions because they were more interesting
to analyze how they were done, but the library can also generate &lt;code&gt;@moduledoc&lt;&#x2F;code&gt;
based on the code of the module, but usually a module needs a context in the
application in order to write their &lt;code&gt;@moduledoc&lt;&#x2F;code&gt; so the feature request is to
make a dependency module graph and include the dependency &lt;code&gt;@moduledoc&lt;&#x2F;code&gt; or the
code of dependency module in the prompt. (TO BE DONE).&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Another interesting feature is to clean all the docs, so this way you can
regenerate them from scratch, so we have created a third task &lt;code&gt;mix lazy_doc.clean&lt;&#x2F;code&gt; which deletes all the &lt;code&gt;@doc&lt;&#x2F;code&gt; annotations, but it keeps &lt;code&gt;@doc false&lt;&#x2F;code&gt; annotations. This is useful when your product has evolved, but your docs
have not evolved with your product.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Make a default prompt to generate docs compliant with &lt;code&gt;ex_docs&lt;&#x2F;code&gt;, this way when
we generate the docs webpage, you can experience the documentation as it was a
usual docs.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Making new projects make you learn a lot of stuff. Usually to share your
projects, you need to write how to use them properly, that is the reason
developers write docs. I do not know a bunch of people who likes writing docs or
they have time to write them. Writing docs maybe does not add too much business
value to the product you are building but it will add a huge value to developers
building the product or the developers using your product and they are gonna be
less prone to making mistakes.&lt;&#x2F;p&gt;
&lt;p&gt;Writing LazyDoc, it allows me to learn about deep aspects of the Elixir core,
Elixir AST and learn what weird stuff you can do. For example&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;elixir&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-elixir &quot;&gt;&lt;code class=&quot;language-elixir&quot; data-lang=&quot;elixir&quot;&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defmodule &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defmodule &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is valid Elixir code, but it is not allowed in LazyDoc.&lt;&#x2F;p&gt;
&lt;p&gt;Writing LazyDoc, I realize that good software sometimes needs to be opinionated,
take a strong opinion and follow it until the end, for example &lt;code&gt;external_doc&lt;&#x2F;code&gt;
feature is really opinionated because some people will like to have the docs in
the code and some other will just like to see the code and not being distracted
but anything else. Another strong opinion that this library takes is what does
with the functions of the same name, basically we understand that they are the
same function to document even that for Elixir it is not. At least every
teammates I asked told me that 2 functions named the same are always related, so
it makes sense to document them together. Same nested named modules does not
make sense in almost any situation, so LazyDoc does not allow it because they
have the same AST structure.&lt;&#x2F;p&gt;
&lt;p&gt;Thank you very much for your reading effort.&lt;&#x2F;p&gt;
&lt;p&gt;You can support &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pxp9&#x2F;lazy_doc&quot;&gt;lazy_doc repo&lt;&#x2F;a&gt; and if you
are curious how LazyDoc docs look, LazyDoc is documented by LazyDoc itself you
can check it in &lt;a href=&quot;https:&#x2F;&#x2F;hexdocs.pm&#x2F;lazy_doc&#x2F;api-reference.html&quot;&gt;lazy_doc
hexdocs&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Fang, async background processing for Rust.</title>
          <pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate>
          <author>pxp9</author>
          <link>https://pxp9.github.io/async-processing/</link>
          <guid>https://pxp9.github.io/async-processing/</guid>
          <description xml:base="https://pxp9.github.io/async-processing/">&lt;p&gt;Even though the first stable version of Rust was released in 2015, there are still some holes in its ecosystem for solving common tasks. One of which is background processing.&lt;&#x2F;p&gt;
&lt;p&gt;In software engineering background processing is a common approach for solving several problems:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Carry out periodic tasks. For example, deliver notifications, update cached values.&lt;&#x2F;li&gt;
&lt;li&gt;Defer expensive work so your application stays responsive while performing calculations in the background&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Most programming languages have go-to background processing frameworks&#x2F;libraries. For example:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;mperham&#x2F;sidekiq&quot;&gt;sidekiq&lt;&#x2F;a&gt;. It uses Redis as a job queue.&lt;&#x2F;li&gt;
&lt;li&gt;Python - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Bogdanp&#x2F;dramatiq&quot;&gt;dramatiq&lt;&#x2F;a&gt;. It uses RabbitMQ as a job queue.&lt;&#x2F;li&gt;
&lt;li&gt;Elixir - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sorentwo&#x2F;oban&quot;&gt;oban&lt;&#x2F;a&gt;. It uses a Postgres DB as a job queue.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The async programming (async&#x2F;await) can be used for background processing but it has several major disadvantages if used directly:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It doesn&#x27;t give control of the number of tasks that are being executed at any given time. So a lot of spawned tasks can overload a thread&#x2F;threads that they&#x27;re started on.&lt;&#x2F;li&gt;
&lt;li&gt;It doesn&#x27;t provide any monitoring which can be useful to investigate your system and find bottlenecks&lt;&#x2F;li&gt;
&lt;li&gt;Tasks are not persistent. So all enqueued tasks are lost on every application restart&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To solve these shortcomings of the async programming we implemented the async processing in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ayrat555&#x2F;fang&quot;&gt;the fang library&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;threaded-fang&quot;&gt;Threaded Fang&lt;&#x2F;h2&gt;
&lt;p&gt;Fang is a background processing library for rust. The first version of Fang was released exactly one year ago. Its key features were:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Each worker is started in a separate thread&lt;&#x2F;li&gt;
&lt;li&gt;A Postgres table is used as the task queue&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This implementation was written for a specific use case - &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ayrat555&#x2F;el_monitorro&quot;&gt;el monitorro bot&lt;&#x2F;a&gt;. This specific implementation of background processing was proved by time. Each day it processes more and more feeds every minute (the current number is more than 3000). Some users host the bot on their infrastructure.&lt;&#x2F;p&gt;
&lt;p&gt;You can find out more about the threaded processing in fang in &lt;a href=&quot;https:&#x2F;&#x2F;www.badykov.com&#x2F;rust&#x2F;fang&#x2F;&quot;&gt;this blog post&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;async-fang&quot;&gt;Async Fang&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;
Async provides significantly reduced CPU and memory overhead, especially for workloads with a large amount of IO-bound tasks, such as servers and databases. All else equal, you can have orders of magnitude more tasks than OS threads, because an async runtime uses a small amount of (expensive) threads to handle a large amount of (cheap) tasks
  &lt;&#x2F;p&gt;
  &lt;footer&gt;&lt;cite title=&quot;Async book&quot;&gt;From the Rust&#x27;s Async book&lt;&#x2F;cite&gt;&lt;&#x2F;footer&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;For some lightweight background tasks, it&#x27;s cheaper to run them on the same thread using async instead of starting one thread per worker. That&#x27;s why we implemented this kind of processing in fang. Its key features:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Each worker is started as a tokio task&lt;&#x2F;li&gt;
&lt;li&gt;If any worker fails during task execution, it&#x27;s restarted&lt;&#x2F;li&gt;
&lt;li&gt;Tasks are saved to a Postgres database. Instead of diesel, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;sfackler&#x2F;rust-postgres&quot;&gt;tokio-postgres&lt;&#x2F;a&gt; is used to interact with a db. The threaded processing uses the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;diesel-rs&#x2F;diesel&quot;&gt;diesel&lt;&#x2F;a&gt; ORM which blocks the thread.&lt;&#x2F;li&gt;
&lt;li&gt;The implementation is based on traits so it&#x27;s easy to implement additional backends (redis, in-memory) to store tasks.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h2&gt;
&lt;p&gt;The usage is straightforward:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Define a serializable task by adding &lt;code&gt;serde&lt;&#x2F;code&gt; derives to a task struct.&lt;&#x2F;li&gt;
&lt;li&gt;Implement &lt;code&gt;AsyncRunnable&lt;&#x2F;code&gt; runnable trait for fang to be able to run it.&lt;&#x2F;li&gt;
&lt;li&gt;Start workers.&lt;&#x2F;li&gt;
&lt;li&gt;Enqueue tasks.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Let&#x27;s go over each step.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;define-a-job&quot;&gt;Define a job&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::serde::{Deserialize, Serialize};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Serialize, Deserialize)]
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serde&lt;&#x2F;span&gt;&lt;span&gt;(crate = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fang::serde&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;MyTask {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MyTask {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{ number }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Fang re-exports &lt;code&gt;serde&lt;&#x2F;code&gt; so it&#x27;s not required to add it to the &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implement-the-asyncrunnable-trait&quot;&gt;Implement the AsyncRunnable trait&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::async_trait;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::typetag;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::AsyncRunnable;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::time::Duration;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;typetag&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;serde&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;AsyncRunnable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyTask {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;queue&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; dyn AsyncQueueable) -&amp;gt; Result&amp;lt;(), Error&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; new_task = MyTask::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.number + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        queue
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert_task&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;new_task as &amp;amp;dyn AsyncRunnable)
&lt;&#x2F;span&gt;&lt;span&gt;            .await
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        log::info!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;the current number is {}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.number);
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::time::sleep(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;Fang uses the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;typetag&quot;&gt;typetag library&lt;&#x2F;a&gt; to serialize trait objects and save them to the queue.&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;async-trait&quot;&gt;async-trait&lt;&#x2F;a&gt; is used for implementing async traits&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;init-queue&quot;&gt;Init queue&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::asynk::async_queue::AsyncQueue;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; max_pool_size: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; queue = AsyncQueue::builder()
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;uri&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;postgres:&#x2F;&#x2F;postgres:postgres@localhost&#x2F;fang&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;max_pool_size&lt;&#x2F;span&gt;&lt;span&gt;(max_pool_size)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;duplicated_tasks&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;start-workers&quot;&gt;Start workers&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::asynk::async_worker_pool::AsyncWorkerPool;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;fang::NoTls;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; pool: AsyncWorkerPool&amp;lt;AsyncQueue&amp;lt;NoTls&amp;gt;&amp;gt; = AsyncWorkerPool::builder()
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;number_of_workers&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;queue&lt;&#x2F;span&gt;&lt;span&gt;(queue.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;pool.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;().await;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;insert-tasks&quot;&gt;Insert tasks&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task = MyTask::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;queue
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;insert_task&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;task1 as &amp;amp;dyn AsyncRunnable)
&lt;&#x2F;span&gt;&lt;span&gt;    .await
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;pitfalls&quot;&gt;Pitfalls&lt;&#x2F;h2&gt;
&lt;p&gt;The async processing is suitable for lightweight tasks. But for heavier tasks it&#x27;s advised to use one of the following approaches:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;start a separate tokio runtime to run fang workers&lt;&#x2F;li&gt;
&lt;li&gt;use the threaded processing feature implemented in fang instead of the async processing&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;future-directions&quot;&gt;Future directions&lt;&#x2F;h2&gt;
&lt;p&gt;There are a couple of features planned for fang:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Retries with different backoff modes&lt;&#x2F;li&gt;
&lt;li&gt;Additional backends (in-memory, redis)&lt;&#x2F;li&gt;
&lt;li&gt;Graceful shutdown for async workers (for the threaded processing this feature is implemented)&lt;&#x2F;li&gt;
&lt;li&gt;Cron jobs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The project is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ayrat555&#x2F;fang&quot;&gt;GitHub&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The async feature and this post is written in collaboration between &lt;a href=&quot;https:&#x2F;&#x2F;www.badykov.com&#x2F;&quot;&gt;Ayrat Badykov&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ayrat555&quot;&gt;github&lt;&#x2F;a&gt;) and &lt;a href=&quot;https:&#x2F;&#x2F;pxp9.github.io&#x2F;&quot;&gt;Pepe Márquez Romero&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pxp9&quot;&gt;github&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
